<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1" />
  <title>Multiplication Warrior - Maze Adventure</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
  <style>
      body {
          margin: 0;
          padding: 0;
          background: #000;
          overflow: hidden;
      }
      canvas {
          display: block;
          margin: 0 auto;
          max-width: 100vw;
          max-height: 100vh;
          object-fit: contain;
      }
  </style>
</head>
<body>

<!-- Load maze generator -->
<script src="js/MazeGenerator.js"></script>

<script>
    // Game constants
    const GAME_CONFIG = {
        PLAYER_MAX_HEALTH: 100,
        TILE_SIZE: 32,
        MAZE_WIDTH: 20,
        MAZE_HEIGHT: 13,
        MENU_HEIGHT: 60,
        ENCOUNTER_CHANCE: 3, // per 1000
        ENCOUNTER_COOLDOWN: 2000,
        // Difficulty settings
        BASE_TIME: 10000, // 10 seconds for first maze
        MIN_TIME: 4000,   // Minimum 4 seconds
        TIME_REDUCTION_PER_LEVEL: 1000 // Reduce 1 second per maze after level 2
    };

    // Game classes and scenes
    class WorldScene extends Phaser.Scene {
        constructor() {
            super('WorldScene');
        }

        create() {
            // Initialize game state
            this.playerMaxHealth = GAME_CONFIG.PLAYER_MAX_HEALTH;
            this.playerHealth = this.playerMaxHealth;
            this.monstersKilled = 0;
            this.mazesCompleted = 0;
            this.encounterCooldown = 0;

            // Maze properties
            this.tileSize = GAME_CONFIG.TILE_SIZE;
            this.mazeWidth = GAME_CONFIG.MAZE_WIDTH;
            this.mazeHeight = GAME_CONFIG.MAZE_HEIGHT;
            
            // Initialize maze elements array
            this.mazeElements = [];
            
            // Initialize battle transition flag
            this.inBattleTransition = false;

            // Generate first maze
            this.generateNewMaze();
            
            // Create UI and controls after maze
            this.createUI();
            this.setupControls();
        }

        generateNewMaze() {
            const generator = new MazeGenerator(this.mazeWidth, this.mazeHeight);
            this.maze = generator.generate();
            this.createDungeonBackground();
            this.createPlayer();
        }

        clearMazeElements() {
            // Remove previous player
            if (this.player) {
                this.player.destroy();
                this.player = null;
            }
            
            // Remove previous walls
            if (this.walls) {
                this.walls.destroy();
                this.walls = null;
            }
            
            // Remove previous maze elements (background, floors, walls, entrance, exit)
            if (this.mazeElements && this.mazeElements.length > 0) {
                this.mazeElements.forEach(element => {
                    if (element && element.destroy && !element.destroyed) {
                        element.destroy();
                    }
                });
                this.mazeElements = [];
            }
        }

        createDungeonBackground() {
            const { width, height } = this.scale;

            // Very dark dungeon background
            const background = this.add.rectangle(width / 2, height / 2, width, height, 0x1A1A1A);
            this.mazeElements.push(background);

            // Create walls group for collision
            this.walls = this.physics.add.staticGroup();

            // Draw maze (offset by menu height)
            const menuOffset = GAME_CONFIG.MENU_HEIGHT;
            for (let y = 0; y < this.mazeHeight; y++) {
                for (let x = 0; x < this.mazeWidth; x++) {
                    const pixelX = x * this.tileSize;
                    const pixelY = y * this.tileSize + menuOffset;

                    if (this.maze[y][x] === 1) {
                        // Wall tile - smaller collision box for better movement
                        const wall = this.add.rectangle(
                            pixelX + this.tileSize/2, 
                            pixelY + this.tileSize/2, 
                            this.tileSize, 
                            this.tileSize, 
                            0x654321
                        );
                        wall.setStrokeStyle(2, 0x8B4513);
                        this.mazeElements.push(wall);
                        
                        // Create a smaller physics body for better collision
                        const wallBody = this.physics.add.existing(wall, true);
                        wallBody.body.setSize(this.tileSize - 4, this.tileSize - 4);
                        this.walls.add(wallBody);
                    } else {
                        // Floor tile
                        const floor = this.add.rectangle(
                            pixelX + this.tileSize/2, 
                            pixelY + this.tileSize/2, 
                            this.tileSize, 
                            this.tileSize, 
                            0x8B7355
                        );
                        this.mazeElements.push(floor);
                    }
                }
            }

            // Add entrance marker (green)
            const entrance = this.add.rectangle(this.tileSize/2, this.tileSize + this.tileSize/2 + menuOffset, this.tileSize, this.tileSize, 0x00FF00);
            this.mazeElements.push(entrance);

            // Add exit marker (red)
            const exitX = (this.mazeWidth - 1) * this.tileSize + this.tileSize/2;
            const exitY = (this.mazeHeight - 2) * this.tileSize + this.tileSize/2 + menuOffset;
            this.exitZone = this.add.rectangle(exitX, exitY, this.tileSize, this.tileSize, 0xFF0000);
            this.mazeElements.push(this.exitZone);
        }

        createPlayer() {
            // Place player at entrance (offset by menu height)
            const menuOffset = GAME_CONFIG.MENU_HEIGHT;
            this.player = this.physics.add.sprite(this.tileSize/2, this.tileSize + this.tileSize/2 + menuOffset, 'player_0');
            this.player.setCollideWorldBounds(true);
            
            // Make player collision box smaller for smoother movement
            this.player.body.setSize(this.tileSize - 8, this.tileSize - 8);
            this.player.body.setOffset(4, 4);
            
            // Start with idle animation
            this.player.play('warrior_idle');

            // Add collision between player and walls
            this.physics.add.collider(this.player, this.walls);
        }

        createUI() {
            this.createTopMenu();
            this.updateUI();
        }

        createTopMenu() {
            const { width } = this.scale;
            const menuHeight = GAME_CONFIG.MENU_HEIGHT;
            
            // Retro brick-style background
            const menuBg = this.add.rectangle(width / 2, menuHeight / 2, width, menuHeight, 0x8B4513);
            
            // Brick pattern for retro look
            const brickWidth = 32;
            const brickHeight = 16;
            
            for (let y = 0; y < Math.ceil(menuHeight / brickHeight); y++) {
                for (let x = 0; x < Math.ceil(width / brickWidth); x++) {
                    const offsetX = (y % 2) * (brickWidth / 2);
                    const brickX = x * brickWidth + offsetX;
                    const brickY = y * brickHeight;
                    
                    if (brickX < width && brickY < menuHeight) {
                        // Brick with subtle variation
                        const brickColor = Phaser.Utils.Array.GetRandom([0xA0522D, 0x8B4513, 0x654321]);
                        const brick = this.add.rectangle(brickX + brickWidth/2, brickY + brickHeight/2, brickWidth - 2, brickHeight - 1, brickColor);
                        
                        // Mortar lines
                        const mortarH = this.add.rectangle(brickX + brickWidth/2, brickY + brickHeight/2, brickWidth - 2, 1, 0x2F2F2F);
                        const mortarV = this.add.rectangle(brickX + brickWidth/2, brickY + brickHeight/2, 1, brickHeight - 1, 0x2F2F2F);
                    }
                }
            }
            
            // Bottom border
            const border = this.add.rectangle(width / 2, menuHeight - 2, width, 4, 0x2F2F2F);
            
            // Create panels for each stat  
            this.createStatPanel(60, menuHeight / 2, 110, 40, 'HP');
            this.createStatPanel(180, menuHeight / 2, 110, 40, 'MONSTRUOS');
            this.createStatPanel(300, menuHeight / 2, 110, 40, 'LABERINTOS');
            this.createStatPanel(420, menuHeight / 2, 110, 40, 'DIFICULTAD');
            
            // Health bar in first panel
            this.healthBarBg = this.add.rectangle(60, menuHeight / 2 + 8, 82, 8, 0x000000);
            this.healthBar = this.add.rectangle(60, menuHeight / 2 + 8, 80, 6, 0x00FF00);
            
            // Text elements (positioned to avoid overlap)
            this.healthText = this.add.text(60, menuHeight / 2 + 2, `${this.playerHealth}/${this.playerMaxHealth}`, {
                fontSize: '10px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 1
            }).setOrigin(0.5);
            
            this.killCountText = this.add.text(180, menuHeight / 2 + 5, `${this.monstersKilled}`, {
                fontSize: '14px',
                color: '#ffff00',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            this.mazeCountText = this.add.text(300, menuHeight / 2 + 5, `${this.mazesCompleted}`, {
                fontSize: '14px',
                color: '#00ffff',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            // Difficulty text (time remaining)
            this.difficultyDisplayText = this.add.text(420, menuHeight / 2 + 5, this.getDifficultyText(), {
                fontSize: '12px',
                color: '#ff9900',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);
        }
        
        createStatPanel(x, y, width, height, label) {
            // Panel background
            const panelBg = this.add.rectangle(x, y, width, height, 0x654321, 0.8);
            const panelInner = this.add.rectangle(x, y, width - 4, height - 4, 0x2F2F2F, 0.6);
            
            // Panel border (retro 3D effect)
            const topHighlight = this.add.rectangle(x, y - height/2 + 1, width, 2, 0xD2B48C);
            const leftHighlight = this.add.rectangle(x - width/2 + 1, y, 2, height, 0xD2B48C);
            const bottomShadow = this.add.rectangle(x, y + height/2 - 1, width, 2, 0x1F1F1F);
            const rightShadow = this.add.rectangle(x + width/2 - 1, y, 2, height, 0x1F1F1F);
            
            // Label (positioned higher to avoid overlap)
            const labelText = this.add.text(x, y - 12, label, {
                fontSize: '9px',
                color: '#D2B48C',
                stroke: '#000000',
                strokeThickness: 1
            }).setOrigin(0.5);
        }

        setupControls() {
            this.cursors = this.input.keyboard.createCursorKeys();
            this.createMobileControls();
        }

        createMobileControls() {
            const { width, height } = this.scale;
            const mazeEndY = GAME_CONFIG.MENU_HEIGHT + (this.mazeHeight * this.tileSize);
            
            // Detect if mobile device
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < window.innerHeight;
            
            // Adjust button size for mobile - much larger
            const buttonSize = isMobile ? 100 : 80;
            const buttonSpacing = isMobile ? 130 : 100;
            const controlsHeight = isMobile ? 180 : 140;
            const controlsY = mazeEndY + (isMobile ? 80 : 60);
            
            // Mobile control background
            this.mobileControlsBg = this.add.rectangle(width / 2, controlsY, width, controlsHeight, 0x2F2F2F, 0.8);
            
            // Virtual directional buttons with better mobile spacing
            this.createDirectionalButton(width / 2, controlsY - (isMobile ? 50 : 40), '↑', 'up', buttonSize);
            this.createDirectionalButton(width / 2 - buttonSpacing, controlsY + (isMobile ? 10 : 5), '←', 'left', buttonSize);
            this.createDirectionalButton(width / 2 + buttonSpacing, controlsY + (isMobile ? 10 : 5), '→', 'right', buttonSize);
            this.createDirectionalButton(width / 2, controlsY + (isMobile ? 70 : 50), '↓', 'down', buttonSize);
            
            // Virtual cursor state
            this.virtualCursors = {
                left: { isDown: false },
                right: { isDown: false },
                up: { isDown: false },
                down: { isDown: false }
            };
        }

        createDirectionalButton(x, y, text, direction, size = 45) {
            // Detect if mobile for larger buttons
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < window.innerHeight;
            const fontSize = isMobile ? '48px' : '36px';
            
            // Button background with 3D effect
            const button = this.add.rectangle(x, y, size, size, 0x654321);
            button.setStrokeStyle(3, 0x8B4513);
            button.setInteractive();
            
            // Add button depth/shadow
            const shadow = this.add.rectangle(x + 2, y + 2, size, size, 0x2F2F2F, 0.6);
            shadow.setDepth(-1);
            
            // Button text
            const buttonText = this.add.text(x, y, text, {
                fontSize: fontSize,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3,
                fontStyle: 'bold'
            }).setOrigin(0.5);

            // Button interactions with better feedback
            button.on('pointerdown', () => {
                this.virtualCursors[direction].isDown = true;
                button.setFillStyle(0x8B4513); // Pressed state
                button.setScale(0.95); // Press effect
                buttonText.setScale(0.95);
            });

            button.on('pointerup', () => {
                this.virtualCursors[direction].isDown = false;
                button.setFillStyle(0x654321); // Normal state
                button.setScale(1);
                buttonText.setScale(1);
            });

            button.on('pointerout', () => {
                this.virtualCursors[direction].isDown = false;
                button.setFillStyle(0x654321); // Normal state
                button.setScale(1);
                buttonText.setScale(1);
            });
        }

        toggleMobileControls(visible) {
            if (this.mobileControlsBg) {
                this.mobileControlsBg.setVisible(visible);
            }
            // Toggle all mobile control elements
            const mazeEndY = GAME_CONFIG.MENU_HEIGHT + (this.mazeHeight * this.tileSize);
            this.children.list.forEach(child => {
                if (child.y > mazeEndY && child.y < this.scale.height - 50) { // Controls are below maze but above bottom
                    child.setVisible(visible);
                }
            });
        }

        hideMobileControls() {
            this.toggleMobileControls(false);
        }

        showMobileControls() {
            this.toggleMobileControls(true);
        }
        
        startBattleTransition() {
            // Block all input and stop player animation
            this.inBattleTransition = true;
            this.player.setVelocity(0);
            this.player.stop();
            this.player.play('warrior_idle');
            
            // Create battle transition effect
            const { width, height } = this.scale;
            
            // Create flash effect
            const flash = this.add.rectangle(width / 2, height / 2, width, height, 0xffffff, 0);
            
            // Flash animation
            this.tweens.add({
                targets: flash,
                alpha: 1,
                duration: 100,
                yoyo: true,
                repeat: 2,
                onComplete: () => {
                    flash.destroy();
                    this.createBattleSwirl();
                }
            });
        }
        
        createBattleSwirl() {
            const { width, height } = this.scale;
            
            // Create swirl overlay
            const swirlBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0);
            
            // Create animated circles for swirl effect
            const circles = [];
            for (let i = 0; i < 8; i++) {
                const circle = this.add.circle(width / 2, height / 2, 20, 0xffffff, 0.8);
                circles.push(circle);
                
                // Animate circles in spiral
                this.tweens.add({
                    targets: circle,
                    x: width / 2 + Math.cos(i * Math.PI / 4) * 200,
                    y: height / 2 + Math.sin(i * Math.PI / 4) * 200,
                    alpha: 0,
                    duration: 800,
                    delay: i * 50
                });
            }
            
            // Fade to black
            this.tweens.add({
                targets: swirlBg,
                alpha: 1,
                duration: 600,
                onComplete: () => {
                    // Clean up circles
                    circles.forEach(circle => circle.destroy());
                    swirlBg.destroy();
                    
                    // Start battle
                    this.scene.pause();
                    this.scene.launch('BattleScene');
                }
            });
        }

        updateUI() {
            const healthPercent = this.playerHealth / this.playerMaxHealth;
            this.healthBar.width = 80 * healthPercent;
            this.healthBar.fillColor = healthPercent > 0.5 ? 0x00FF00 : (healthPercent > 0.25 ? 0xFFFF00 : 0xFF0000);
            this.healthText.setText(`${this.playerHealth}/${this.playerMaxHealth}`);
            this.killCountText.setText(`${this.monstersKilled}`);
            this.mazeCountText.setText(`${this.mazesCompleted}`);
            
            // Update difficulty display
            if (this.difficultyDisplayText) {
                this.difficultyDisplayText.setText(this.getDifficultyText());
            }
        }
        
        getDifficultyText() {
            const currentLevel = this.mazesCompleted + 1;
            let timeLimit;
            
            if (currentLevel === 1) {
                timeLimit = 10;
            } else if (currentLevel === 2) {
                timeLimit = 8;
            } else if (currentLevel === 3) {
                timeLimit = 6;
            } else {
                const reductionFromLevel4 = (currentLevel - 3);
                timeLimit = 6 - reductionFromLevel4;
                timeLimit = Math.max(timeLimit, 4); // Minimum 4 seconds
            }
            
            return `${timeLimit}s`;
        }

        update(time, delta) {
            // Don't process input during battle transition
            if (this.inBattleTransition) {
                this.player.setVelocity(0);
                return;
            }
            
            const speed = 100;
            let isMoving = false;

            this.player.setVelocity(0);
            
            // Movement with boundary checks (accounting for menu offset)
            const menuOffset = GAME_CONFIG.MENU_HEIGHT;
            
            // Check both physical and virtual controls
            const leftPressed = this.cursors.left.isDown || this.virtualCursors.left.isDown;
            const rightPressed = this.cursors.right.isDown || this.virtualCursors.right.isDown;
            const upPressed = this.cursors.up.isDown || this.virtualCursors.up.isDown;
            const downPressed = this.cursors.down.isDown || this.virtualCursors.down.isDown;
            
            if (leftPressed && this.player.x > 16) {
                this.player.setVelocityX(-speed);
                this.player.setFlipX(true); // Flip sprite when moving left
                isMoving = true;
            } else if (rightPressed && this.player.x < 624) {
                this.player.setVelocityX(speed);
                this.player.setFlipX(false); // Normal direction when moving right
                isMoving = true;
            }
            if (upPressed && this.player.y > 16 + menuOffset) {
                this.player.setVelocityY(-speed);
                isMoving = true;
            } else if (downPressed && this.player.y < menuOffset + (this.mazeHeight * this.tileSize) - 16) {
                this.player.setVelocityY(speed);
                isMoving = true;
            }
            
            // Handle player animations (simple flip without erratic movement)
            if (isMoving) {
                if (this.player.anims.currentAnim?.key !== 'warrior_walk') {
                    this.player.play('warrior_walk');
                }
            } else {
                if (this.player.anims.currentAnim?.key !== 'warrior_idle') {
                    this.player.play('warrior_idle');
                }
            }

            // Check if player reached exit
            const exitX = (this.mazeWidth - 1) * this.tileSize;
            const exitY = (this.mazeHeight - 2) * this.tileSize + menuOffset;

            if (Phaser.Geom.Rectangle.Contains(
                new Phaser.Geom.Rectangle(exitX, exitY, this.tileSize, this.tileSize),
                this.player.x, this.player.y
            )) {
                this.mazesCompleted++;
                
                // Clear and recreate maze elements
                this.clearMazeElements();
                const generator = new MazeGenerator(this.mazeWidth, this.mazeHeight);
                this.maze = generator.generate();
                this.createDungeonBackground();
                this.createPlayer();
                
                // Recreate UI and controls to ensure they're always there
                this.createUI();
                this.setupControls();
            }

            // Random encounters when moving (only if not in transition)
            if (isMoving && !this.inBattleTransition && this.encounterCooldown <= 0 && Phaser.Math.Between(0, 1000) < GAME_CONFIG.ENCOUNTER_CHANCE) {
                this.encounterCooldown = GAME_CONFIG.ENCOUNTER_COOLDOWN;
                this.inBattleTransition = true; // Block further input
                this.hideMobileControls();
                this.startBattleTransition();
            }
            this.encounterCooldown -= delta;
        }
    }
    class PreloadScene extends Phaser.Scene {
        constructor() {
            super('PreloadScene');
        }
        preload() {
            // Create better warrior sprite sheet
            this.createBetterWarriorSprites();
            
            // Load enemy sprites
            this.load.image('enemy1', 'assets/enemies/beast1.png');
            this.load.image('enemy2', 'assets/enemies/beast2.png');
            this.load.image('enemy3', 'assets/enemies/beast3.png');
            this.load.image('enemy4', 'assets/enemies/beast4.png');
        }
        
        createBetterWarriorSprites() {
            const canvas = document.createElement('canvas');
            canvas.width = 96; // 3 frames x 32px (tamaño correcto para tiles)
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Frame 1: Idle (0-31px)
            this.drawBetterWarrior(ctx, 0, 'idle');
            // Frame 2: Walk 1 (32-63px) 
            this.drawBetterWarrior(ctx, 32, 'walk1');
            // Frame 3: Walk 2 (64-95px)
            this.drawBetterWarrior(ctx, 64, 'walk2');
            
            // Create texture and add to cache
            this.textures.addCanvas('player', canvas);
            
            // Also create individual frame textures
            const frameCanvas1 = document.createElement('canvas');
            frameCanvas1.width = 32;
            frameCanvas1.height = 32;
            const frameCtx1 = frameCanvas1.getContext('2d');
            frameCtx1.drawImage(canvas, 0, 0, 32, 32, 0, 0, 32, 32);
            this.textures.addCanvas('player_0', frameCanvas1);
            
            const frameCanvas2 = document.createElement('canvas');
            frameCanvas2.width = 32;
            frameCanvas2.height = 32;
            const frameCtx2 = frameCanvas2.getContext('2d');
            frameCtx2.drawImage(canvas, 32, 0, 32, 32, 0, 0, 32, 32);
            this.textures.addCanvas('player_1', frameCanvas2);
            
            const frameCanvas3 = document.createElement('canvas');
            frameCanvas3.width = 32;
            frameCanvas3.height = 32;
            const frameCtx3 = frameCanvas3.getContext('2d');
            frameCtx3.drawImage(canvas, 64, 0, 32, 32, 0, 0, 32, 32);
            this.textures.addCanvas('player_2', frameCanvas3);
        }
        
        drawBetterWarrior(ctx, offsetX, frameType) {
            // Limpiar el área
            ctx.clearRect(offsetX, 0, 32, 32);
            
            // Casco/cabeza (más pequeño y mejor)
            ctx.fillStyle = '#C0C0C0'; // Casco plateado
            ctx.fillRect(offsetX + 12, 4, 8, 8);
            
            // Cara visible
            ctx.fillStyle = '#FDBCB4'; // Piel
            ctx.fillRect(offsetX + 14, 6, 4, 4);
            
            // Ojos
            ctx.fillStyle = '#000000';
            ctx.fillRect(offsetX + 15, 7, 1, 1);
            ctx.fillRect(offsetX + 17, 7, 1, 1);
            
            // Cuerpo armadura
            ctx.fillStyle = '#4169E1'; // Azul real
            ctx.fillRect(offsetX + 11, 12, 10, 8);
            
            // Detalles de armadura
            ctx.fillStyle = '#FFD700'; // Oro
            ctx.fillRect(offsetX + 13, 14, 6, 1);
            ctx.fillRect(offsetX + 15, 16, 2, 2);
            
            // Brazos y posición según frame
            ctx.fillStyle = '#4169E1';
            if (frameType === 'idle') {
                // Brazos normales
                ctx.fillRect(offsetX + 8, 14, 3, 6);
                ctx.fillRect(offsetX + 21, 14, 3, 6);
                // Espada
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(offsetX + 25, 10, 1, 8);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(offsetX + 24, 17, 3, 2);
            } else if (frameType === 'walk1') {
                // Brazo izq adelante, der atrás
                ctx.fillRect(offsetX + 9, 13, 3, 6);
                ctx.fillRect(offsetX + 20, 15, 3, 6);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(offsetX + 23, 11, 1, 8);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(offsetX + 22, 18, 3, 2);
            } else if (frameType === 'walk2') {
                // Brazo der adelante, izq atrás
                ctx.fillRect(offsetX + 7, 15, 3, 6);
                ctx.fillRect(offsetX + 22, 13, 3, 6);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(offsetX + 25, 9, 1, 8);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(offsetX + 24, 16, 3, 2);
            }
            
            // Piernas según frame
            ctx.fillStyle = '#8B4513'; // Pantalones marrones
            if (frameType === 'idle') {
                // Piernas rectas
                ctx.fillRect(offsetX + 13, 20, 3, 8);
                ctx.fillRect(offsetX + 16, 20, 3, 8);
            } else if (frameType === 'walk1') {
                // Pierna izq adelante
                ctx.fillRect(offsetX + 14, 20, 3, 8);
                ctx.fillRect(offsetX + 15, 21, 3, 7);
            } else if (frameType === 'walk2') {
                // Pierna der adelante
                ctx.fillRect(offsetX + 12, 21, 3, 7);
                ctx.fillRect(offsetX + 16, 20, 3, 8);
            }
            
            // Botas
            ctx.fillStyle = '#2F2F2F';
            if (frameType === 'idle') {
                ctx.fillRect(offsetX + 12, 28, 4, 3);
                ctx.fillRect(offsetX + 16, 28, 4, 3);
            } else if (frameType === 'walk1') {
                ctx.fillRect(offsetX + 13, 28, 4, 3);
                ctx.fillRect(offsetX + 14, 29, 4, 2);
            } else if (frameType === 'walk2') {
                ctx.fillRect(offsetX + 11, 29, 4, 2);
                ctx.fillRect(offsetX + 15, 28, 4, 3);
            }
        }
        create() {
            // Create warrior animations
            this.createWarriorAnimations();
            this.scene.start('IntroScene');
        }
        
        createWarriorAnimations() {
            // Create animations using individual frame textures
            this.anims.create({
                key: 'warrior_idle',
                frames: [{ key: 'player_0' }],
                frameRate: 1,
                repeat: -1
            });
            
            this.anims.create({
                key: 'warrior_walk',
                frames: [
                    { key: 'player_1' },
                    { key: 'player_0' },
                    { key: 'player_2' },
                    { key: 'player_0' }
                ],
                frameRate: 8,
                repeat: -1
            });
            
            this.anims.create({
                key: 'warrior_attack',
                frames: [{ key: 'player_0' }],
                frameRate: 8,
                repeat: 0
            });
        }
    }

    class IntroScene extends Phaser.Scene {
        constructor() {
            super('IntroScene');
        }
        create() {
            const { width, height } = this.scale;
            this.add.text(width / 2, height / 2, '¡Prepárate para explorar laberintos!', {
                fontSize: '24px',
                color: '#ffffff',
            }).setOrigin(0.5);

            this.time.delayedCall(2000, () => {
                this.scene.start('WorldScene');
            });
        }
    }

    class BattleScene extends Phaser.Scene {
        constructor() {
            super('BattleScene');
        }
        
        create() {
            const { width, height } = this.scale;
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < window.innerHeight;
            
            // Create mystical battle arena
            this.createBattleArena();
            
            // Select random enemy
            const enemyTypes = ['enemy1', 'enemy2', 'enemy3', 'enemy4'];
            const randomEnemyType = Phaser.Utils.Array.GetRandom(enemyTypes);
            
            // Make sprites bigger (positioned in main game area)
            const gameAreaHeight = isMobile ? 520 : 480; // More space for mobile
            this.enemy = this.add.sprite(width - 150, gameAreaHeight / 2, randomEnemyType);
            this.enemy.setScale(3);
            this.enemy.enemyType = randomEnemyType; // Store for animations
            
            this.player = this.add.sprite(150, gameAreaHeight / 2, 'player_0');
            this.player.setScale(3);
            
            // Create enemy animations
            this.createEnemyAnimations();
            
            // Start idle animations
            this.player.play('warrior_idle');
            this.startEnemyIdle();

            // Health system
            this.playerMaxHealth = 100;
            this.playerHealth = this.scene.get('WorldScene').playerHealth || this.playerMaxHealth;
            this.enemyMaxHealth = 60;
            this.enemyHealth = this.enemyMaxHealth;
            
            this.createHealthBars();

            this.question = this.generateQuestion();
            this.timeLeft = this.calculateTimeLimit();
            this.battleEnded = false;

            // Adjust text positions for mobile
            const questionY = isMobile ? gameAreaHeight / 2 - 100 : gameAreaHeight / 2 - 80;
            const inputY = isMobile ? gameAreaHeight / 2 - 50 : gameAreaHeight / 2 - 30;
            
            this.questionText = this.add.text(width / 2, questionY, this.question.text, {
                fontSize: isMobile ? '28px' : '32px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);

            // Create input field manually
            this.inputText = this.add.text(width / 2, inputY, '', {
                fontSize: isMobile ? '22px' : '24px',
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 2,
                backgroundColor: '#333333',
                padding: { x: 10, y: 5 }
            }).setOrigin(0.5);
            
            this.currentInput = '';
            this.inputText.setText('_');
            
            // Show difficulty level and time limit
            const worldScene = this.scene.get('WorldScene');
            const currentLevel = worldScene ? worldScene.mazesCompleted + 1 : 1;
            const timeInSeconds = Math.ceil(this.timeLeft / 1000);
            
            this.difficultyText = this.add.text(width / 2, 20, `Nivel ${currentLevel} - Tiempo: ${timeInSeconds}s`, {
                fontSize: isMobile ? '16px' : '18px',
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 2,
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            // Handle keyboard input
            this.input.keyboard.on('keydown', (event) => {
                if (event.key >= '0' && event.key <= '9') {
                    this.addDigit(event.key);
                } else if (event.key === 'Backspace') {
                    this.removeDigit();
                } else if (event.key === 'Enter') {
                    this.submitAnswer();
                }
            });

            // Create mobile numeric keypad
            this.createNumericKeypad();

            const resultY = isMobile ? gameAreaHeight / 2 : gameAreaHeight / 2 + 20;
            const timerY = isMobile ? gameAreaHeight / 2 + 40 : gameAreaHeight / 2 + 60;
            
            this.resultText = this.add.text(width / 2, resultY, '', {
                fontSize: isMobile ? '20px' : '24px',
                color: '#ffff00',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            // Timer display
            this.timerText = this.add.text(width / 2, timerY, '', {
                fontSize: isMobile ? '16px' : '18px',
                color: '#ff0000',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            this.updateTimer();
        }

        createNumericKeypad() {
            const { width, height } = this.scale;
            // Detect mobile device
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < window.innerHeight;
            const gameAreaHeight = isMobile ? 520 : 480;
            
            // Adjust sizes for mobile - much larger
            const keypadHeight = isMobile ? 320 : 240;
            const keypadStartY = gameAreaHeight + (isMobile ? 40 : 30);
            const buttonSize = isMobile ? 80 : 65;
            const spacing = isMobile ? 100 : 80;
            const rowSpacing = isMobile ? 85 : 70;
            
            // Keypad background
            const keypadY = gameAreaHeight + keypadHeight / 2;
            this.add.rectangle(width / 2, keypadY, width, keypadHeight, 0x2F2F2F, 0.9);
            
            // Number buttons (1-9)
            const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
            for (let i = 0; i < 9; i++) {
                const row = Math.floor(i / 3);
                const col = i % 3;
                const x = width / 2 - spacing + (col * spacing);
                const y = keypadStartY + (row * rowSpacing);
                
                this.createNumberButton(x, y, numbers[i], buttonSize);
            }
            
            // Bottom row with larger spacing
            const bottomY = keypadStartY + (3 * rowSpacing);
            
            // Zero button
            this.createNumberButton(width / 2 - spacing, bottomY, '0', buttonSize);
            
            // Backspace button
            this.createNumberButton(width / 2, bottomY, '⌫', buttonSize, true);
            
            // OK button
            this.createNumberButton(width / 2 + spacing, bottomY, 'OK', buttonSize, false, true);
        }

        createNumberButton(x, y, text, size, isBackspace = false, isOK = false) {
            // Button background
            let buttonColor = 0x654321;
            if (isOK) buttonColor = 0x228B22;
            else if (isBackspace) buttonColor = 0x8B4513;
            
            const button = this.add.rectangle(x, y, size, size, buttonColor);
            button.setStrokeStyle(3, 0x8B4513);
            button.setInteractive();
            
            // Add button depth
            const shadow = this.add.rectangle(x + 2, y + 2, size, size, 0x2F2F2F, 0.6);
            shadow.setDepth(-1);
            
            // Detect mobile for larger text
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < window.innerHeight;
            
            // Button text with mobile scaling - much larger
            let fontSize;
            if (isMobile) {
                fontSize = isOK ? '32px' : '42px';
            } else {
                fontSize = isOK ? '24px' : '32px';
            }
            
            const buttonText = this.add.text(x, y, text, {
                fontSize: fontSize,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: 3,
                fontStyle: 'bold'
            }).setOrigin(0.5);

            // Button interactions
            button.on('pointerdown', () => {
                button.setFillStyle(buttonColor + 0x333333); // Pressed state
                button.setScale(0.9); // Press effect
                buttonText.setScale(0.9);
                
                if (isBackspace) {
                    this.removeDigit();
                } else if (isOK) {
                    this.submitAnswer();
                } else {
                    this.addDigit(text);
                }
            });

            button.on('pointerup', () => {
                button.setFillStyle(buttonColor); // Normal state
                button.setScale(1);
                buttonText.setScale(1);
            });

            button.on('pointerout', () => {
                button.setFillStyle(buttonColor); // Normal state
                button.setScale(1);
                buttonText.setScale(1);
            });
        }

        addDigit(digit) {
            if (this.currentInput.length < 4) { // Limit input length
                this.currentInput += digit;
                this.inputText.setText(this.currentInput + '_');
            }
        }

        removeDigit() {
            this.currentInput = this.currentInput.slice(0, -1);
            this.inputText.setText(this.currentInput + '_');
        }

        submitAnswer() {
            const val = parseInt(this.currentInput);
            if (val === this.question.result) {
                this.handleCorrectAnswer();
            } else {
                this.handleWrongAnswer();
            }
        }
        
        createBattleArena() {
            const { width, height } = this.scale;
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < window.innerHeight;
            const gameAreaHeight = isMobile ? 520 : 480;
            
            // Subtle background variations with dungeon tones
            const baseColors = [0x2F2F2F, 0x3A3A3A, 0x454545];
            const floorColors = [0x8B7355, 0x696969, 0x654321];
            
            const bgColor = Phaser.Utils.Array.GetRandom(baseColors);
            const floorColor = Phaser.Utils.Array.GetRandom(floorColors);
            
            // Dark stone background (only for game area, not keypad area)
            this.add.rectangle(width / 2, gameAreaHeight / 2, width, gameAreaHeight, bgColor);
            
            // Create subtle brick pattern on walls (avoiding center area)
            const brickWidth = 24;
            const brickHeight = 12;
            
            // Top area bricks
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < Math.ceil(width / brickWidth); x++) {
                    const offsetX = (y % 2) * (brickWidth / 2);
                    const brickX = x * brickWidth + offsetX;
                    const brickY = y * brickHeight;
                    
                    if (brickX < width) {
                        this.add.rectangle(brickX + brickWidth/2, brickY + brickHeight/2, brickWidth - 2, brickHeight - 1, 0x4A4A4A, 0.6);
                    }
                }
            }
            
            // Bottom area bricks (above floor)
            for (let y = 0; y < 2; y++) {
                for (let x = 0; x < Math.ceil(width / brickWidth); x++) {
                    const offsetX = (y % 2) * (brickWidth / 2);
                    const brickX = x * brickWidth + offsetX;
                    const brickY = gameAreaHeight - 100 + y * brickHeight;
                    
                    if (brickX < width) {
                        this.add.rectangle(brickX + brickWidth/2, brickY + brickHeight/2, brickWidth - 2, brickHeight - 1, 0x4A4A4A, 0.6);
                    }
                }
            }
            
            // Side area bricks (avoiding center)
            for (let y = 3; y < Math.ceil((gameAreaHeight - 100) / brickHeight) - 2; y++) {
                // Left side
                for (let x = 0; x < 3; x++) {
                    const offsetX = (y % 2) * (brickWidth / 2);
                    const brickX = x * brickWidth + offsetX;
                    const brickY = y * brickHeight;
                    
                    if (brickX < 100) {
                        this.add.rectangle(brickX + brickWidth/2, brickY + brickHeight/2, brickWidth - 2, brickHeight - 1, 0x4A4A4A, 0.6);
                    }
                }
                
                // Right side
                for (let x = Math.ceil(width / brickWidth) - 3; x < Math.ceil(width / brickWidth); x++) {
                    const offsetX = (y % 2) * (brickWidth / 2);
                    const brickX = x * brickWidth + offsetX;
                    const brickY = y * brickHeight;
                    
                    if (brickX >= width - 100 && brickX < width) {
                        this.add.rectangle(brickX + brickWidth/2, brickY + brickHeight/2, brickWidth - 2, brickHeight - 1, 0x4A4A4A, 0.6);
                    }
                }
            }
            
            // Stone floor
            this.add.rectangle(width / 2, gameAreaHeight - 40, width, 80, floorColor);
            
            // Simple stone pattern on floor
            for (let i = 0; i < 8; i++) {
                const stoneX = Phaser.Math.Between(50, width - 50);
                const stoneY = Phaser.Math.Between(gameAreaHeight - 70, gameAreaHeight - 20);
                const stoneSize = Phaser.Math.Between(3, 6);
                this.add.circle(stoneX, stoneY, stoneSize, 0x555555, 0.4);
            }
        }
        
        createHealthBars() {
            const { width } = this.scale;
            
            // Player health bar
            this.add.text(20, 10, 'Guerrero', { fontSize: '14px', color: '#ffffff', stroke: '#000000', strokeThickness: 1 });
            this.playerHealthBg = this.add.rectangle(100, 30, 102, 12, 0x000000);
            this.playerHealthBar = this.add.rectangle(100, 30, 100, 10, 0x00FF00);
            this.playerHealthText = this.add.text(155, 45, '', { fontSize: '12px', color: '#ffffff', stroke: '#000000', strokeThickness: 1 });
            
            // Enemy health bar - dynamic name based on enemy type
            const enemyNames = {
                'enemy1': 'Bestia',
                'enemy2': 'Orco',
                'enemy3': 'Dragón',
                'enemy4': 'Esqueleto'
            };
            const enemyName = enemyNames[this.enemy.enemyType] || 'Bestia';
            this.add.text(width - 150, 10, enemyName, { fontSize: '14px', color: '#ffffff', stroke: '#000000', strokeThickness: 1 });
            this.enemyHealthBg = this.add.rectangle(width - 100, 30, 102, 12, 0x000000);
            this.enemyHealthBar = this.add.rectangle(width - 100, 30, 100, 10, 0xFF0000);
            this.enemyHealthText = this.add.text(width - 200, 45, '', { fontSize: '12px', color: '#ffffff', stroke: '#000000', strokeThickness: 1 });
            
            this.updateHealthBars();
        }
        
        updateHealthBars() {
            // Player health bar
            const playerHealthPercent = this.playerHealth / this.playerMaxHealth;
            this.playerHealthBar.width = 100 * playerHealthPercent;
            this.playerHealthBar.fillColor = playerHealthPercent > 0.5 ? 0x00FF00 : (playerHealthPercent > 0.25 ? 0xFFFF00 : 0xFF0000);
            this.playerHealthText.setText(`${this.playerHealth}/${this.playerMaxHealth}`);
            
            // Enemy health bar
            const enemyHealthPercent = this.enemyHealth / this.enemyMaxHealth;
            this.enemyHealthBar.width = 100 * enemyHealthPercent;
            this.enemyHealthBar.fillColor = enemyHealthPercent > 0.5 ? 0xFF0000 : (enemyHealthPercent > 0.25 ? 0xFF8800 : 0x880000);
            this.enemyHealthText.setText(`${this.enemyHealth}/${this.enemyMaxHealth}`);
        }
        
        handleCorrectAnswer() {
            if (this.battleEnded) return;
            this.battleEnded = true;
            this.resultText.setText('¡Correcto! Atacas a la bestia');
            
            // Play player attack animation
            this.playPlayerAttack();
            
            this.enemyHealth -= 20;
            this.updateHealthBars();
            
            if (this.enemyHealth <= 0) {
                // Increase kill counter and heal player
                const worldScene = this.scene.get('WorldScene');
                worldScene.monstersKilled += 1;
                worldScene.playerHealth += 5;
                if (worldScene.playerHealth > worldScene.playerMaxHealth) {
                    worldScene.playerHealth = worldScene.playerMaxHealth;
                }
                worldScene.updateUI();
                
                this.resultText.setText('¡Victoria! Bestia derrotada (+5 HP)');
                this.time.delayedCall(2000, () => {
                    this.scene.stop();
                    const worldScene = this.scene.get('WorldScene');
                    worldScene.inBattleTransition = false; // Re-enable input
                    this.scene.resume('WorldScene');
                    worldScene.showMobileControls();
                });
            } else {
                this.time.delayedCall(1000, () => {
                    this.battleEnded = false;
                    this.question = this.generateQuestion();
                    this.questionText.setText(this.question.text);
                    this.currentInput = '';
                    this.inputText.setText('_');
                    this.resultText.setText('');
                    this.timeLeft = this.calculateTimeLimit();
                    this.updateTimer();
                });
            }
        }
        
        handleWrongAnswer() {
            if (this.battleEnded) return;
            this.battleEnded = true;
            this.resultText.setText(`¡Fallaste! La respuesta era ${this.question.result}`);
            
            // Play enemy attack animation
            this.playEnemyAttack();
            
            this.playerHealth -= 15;
            
            if (this.playerHealth < 0) {
                this.playerHealth = 0;
            }
            
            this.updateHealthBars();
            
            const worldScene = this.scene.get('WorldScene');
            worldScene.playerHealth = this.playerHealth;
            worldScene.updateUI();
            
            if (this.playerHealth <= 0) {
                this.resultText.setText('¡Derrota! Has sido vencido');
                this.time.delayedCall(2000, () => {
                    this.scene.stop();
                    this.scene.start('WorldScene');
                    worldScene.playerHealth = this.playerMaxHealth;
                    worldScene.updateUI();
                });
            } else {
                this.time.delayedCall(2000, () => {
                    this.battleEnded = false;
                    this.question = this.generateQuestion();
                    this.questionText.setText(this.question.text);
                    this.currentInput = '';
                    this.inputText.setText('_');
                    this.resultText.setText('');
                    this.timeLeft = this.calculateTimeLimit();
                    this.updateTimer();
                });
            }
        }

        update(time, delta) {
            if (!this.battleEnded) {
                this.timeLeft -= delta;
                if (this.timeLeft <= 0) {
                    this.handleWrongAnswer();
                }
                this.updateTimer();
            }
        }
        
        updateTimer() {
            const seconds = Math.ceil(this.timeLeft / 1000);
            this.timerText.setText(`Tiempo: ${seconds}s`);
            
            // Update difficulty text with current time
            if (this.difficultyText) {
                const worldScene = this.scene.get('WorldScene');
                const currentLevel = worldScene ? worldScene.mazesCompleted + 1 : 1;
                const maxTime = Math.ceil(this.calculateTimeLimit() / 1000);
                this.difficultyText.setText(`Nivel ${currentLevel} - Tiempo máximo: ${maxTime}s`);
            }
            
            if (seconds <= 2) {
                this.timerText.setColor('#ff0000');
            } else if (seconds <= 3) {
                this.timerText.setColor('#ffaa00');
            } else {
                this.timerText.setColor('#ffffff');
            }
        }

        generateQuestion() {
            const a = Phaser.Math.Between(2, 12);
            const b = Phaser.Math.Between(2, 12);
            return {
                text: `${a} × ${b} = ?`,
                result: a * b
            };
        }
        
        calculateTimeLimit() {
            // Get current maze level from WorldScene
            const worldScene = this.scene.get('WorldScene');
            const currentLevel = worldScene ? worldScene.mazesCompleted + 1 : 1;
            
            let timeLimit;
            
            if (currentLevel === 1) {
                // Level 1: 10 seconds
                timeLimit = GAME_CONFIG.BASE_TIME;
            } else if (currentLevel === 2) {
                // Level 2: 8 seconds
                timeLimit = GAME_CONFIG.BASE_TIME - 2000;
            } else if (currentLevel === 3) {
                // Level 3: 6 seconds
                timeLimit = GAME_CONFIG.BASE_TIME - 4000;
            } else {
                // Level 4+: Reduce 1 second per level, minimum 4 seconds
                const reductionFromLevel4 = (currentLevel - 3) * GAME_CONFIG.TIME_REDUCTION_PER_LEVEL;
                timeLimit = GAME_CONFIG.BASE_TIME - 4000 - reductionFromLevel4;
                
                // Ensure minimum time
                timeLimit = Math.max(timeLimit, GAME_CONFIG.MIN_TIME);
            }
            
            return timeLimit;
        }
        
        createEnemyAnimations() {
            // Enemy animations are handled via tweens, not sprite animations
            // This keeps the code simpler since enemies are single-frame sprites
        }
        
        startEnemyIdle() {
            // Simple breathing animation for enemy
            this.enemyIdleTween = this.tweens.add({
                targets: this.enemy,
                scaleX: 3.1,
                scaleY: 2.9,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
        }
        
        playEnemyAttack() {
            // Stop idle animation
            if (this.enemyIdleTween) {
                this.enemyIdleTween.stop();
            }
            
            // Attack animation - quick forward lunge
            this.tweens.add({
                targets: this.enemy,
                x: this.enemy.x - 50,
                scaleX: 3.3,
                scaleY: 2.7,
                duration: 200,
                yoyo: true,
                onComplete: () => {
                    // Resume idle
                    this.startEnemyIdle();
                }
            });
        }
        
        playPlayerAttack() {
            // Player attack animation
            this.player.play('warrior_attack');
            
            this.tweens.add({
                targets: this.player,
                x: this.player.x + 30,
                scaleX: 3.2,
                duration: 150,
                yoyo: true,
                onComplete: () => {
                    this.player.play('warrior_idle');
                }
            });
        }
    }

    // Detect mobile device and adjust game height
    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < window.innerHeight;
    const gameHeight = isMobile ? 1000 : 900; // Much more height for larger keyboards
    
    const config = {
        type: Phaser.AUTO,
        width: 640,
        height: gameHeight,
        backgroundColor: '#000000',
        parent: 'game-container',
        scene: [PreloadScene, IntroScene, WorldScene, BattleScene],
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: false
            }
        },
        dom: {
            createContainer: true
        }
    };

    const game = new Phaser.Game(config);
</script>
</body>
</html>